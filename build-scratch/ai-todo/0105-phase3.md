ç°åœ¨è¿›å…¥ Phase 3: The Jailer (æ²™ç®±æ‰§è¡Œ)ã€‚

è¿™ä¸€é˜¶æ®µçš„æ ¸å¿ƒä»»åŠ¡æ˜¯ï¼šPlatform å¯åŠ¨ä¸€ä¸ª Docker å®¹å™¨ï¼ŒæŠŠåˆšåˆšå‡†å¤‡å¥½çš„æºç æŒ‚è½½è¿›å»ï¼Œå¹¶åœ¨å®¹å™¨å†…æ‰§è¡Œå‘½ä»¤éªŒè¯å®ƒèƒ½â€œçœ‹è§â€ä»£ç ã€‚

Phase 3 å®æ–½æ­¥éª¤
æˆ‘ä»¬éœ€è¦åœ¨ healflow-engine æ¨¡å—ä¸­å®ç° Docker çš„è°ƒåº¦é€»è¾‘ã€‚ä¸ºäº†ä¿æŒæœ€å¤§çµæ´»æ€§å’Œå¯¹æ ‡å‡†è¾“å…¥è¾“å‡ºï¼ˆSTDIN/OUTï¼‰çš„æ§åˆ¶ï¼Œæˆ‘ä»¬ç»§ç»­ä½¿ç”¨ JDK åŸç”Ÿçš„ ProcessBuilderã€‚

ç¬¬ä¸€æ­¥ï¼šç¼–å†™æµè¯»å–å·¥å…· (StreamGobbler)
åœ¨ Java ä¸­ä½¿ç”¨ ProcessBuilder æœ€å®¹æ˜“è¸©çš„å‘å°±æ˜¯ç¼“å†²åŒºæ»¡å¯¼è‡´æ­»é”ã€‚å¿…é¡»å¼€å¯ç‹¬ç«‹çº¿ç¨‹å»è¯»å–å­è¿›ç¨‹çš„è¾“å‡ºæµã€‚

æ–°å»ºå·¥å…·ç±»ï¼šcom.healflow.engine.utils.StreamGobbler.java

Java

package com.healflow.engine.utils;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.function.Consumer;

/**
* ä¸“é—¨ç”¨äºåå™¬å­è¿›ç¨‹è¾“å‡ºæµï¼Œé˜²æ­¢æ­»é”
  */
  public class StreamGobbler implements Runnable {
  private static final Logger log = LoggerFactory.getLogger(StreamGobbler.class);

  private final InputStream inputStream;
  private final Consumer<String> consumer;

  public StreamGobbler(InputStream inputStream, Consumer<String> consumer) {
  this.inputStream = inputStream;
  this.consumer = consumer;
  }

  @Override
  public void run() {
  try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {
  String line;
  while ((line = reader.readLine()) != null) {
  consumer.accept(line);
  }
  } catch (Exception e) {
  log.error("Error reading stream", e);
  }
  }
  }
  ç¬¬äºŒæ­¥ï¼šç¼–å†™æ²™ç®±ç®¡ç†å™¨ (DockerSandboxManager)
  è¿™æ˜¯æœ¬é˜¶æ®µçš„æ ¸å¿ƒã€‚æˆ‘ä»¬å°†å®ç°ä¸€ä¸ªæ–¹æ³•ï¼Œèƒ½å¤Ÿå¯åŠ¨ Docker å¹¶æŒ‚è½½ç›®å½•ã€‚

æ–°å»ºç±»ï¼šcom.healflow.engine.sandbox.DockerSandboxManager.java

Java

package com.healflow.engine.sandbox;

import com.healflow.engine.utils.StreamGobbler;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

@Service
public class DockerSandboxManager {

    private static final Logger log = LoggerFactory.getLogger(DockerSandboxManager.class);

    // é»˜è®¤ä½¿ç”¨ ubuntu è¿›è¡Œæµ‹è¯•ï¼Œåç»­æ¢æˆ claude-code é•œåƒ
    @Value("${healflow.sandbox.image:ubuntu:latest}")
    private String sandboxImage;

    /**
     * åœ¨æ²™ç®±ä¸­æ‰§è¡Œå‘½ä»¤
     * @param appId åº”ç”¨ID
     * @param hostSourcePath å®¿ä¸»æœºæºç ç»å¯¹è·¯å¾„
     * @param command è¦æ‰§è¡Œçš„å‘½ä»¤
     */
    public void runInSandbox(String appId, Path hostSourcePath, String... command) {
        log.info("ğŸ³ Preparing sandbox for app: {}", appId);

        // æ„é€  Docker å‘½ä»¤
        // docker run --rm -v /host/path:/container/src ubuntu ls -l /container/src
        List<String> dockerCmd = new ArrayList<>();
        dockerCmd.add("docker");
        dockerCmd.add("run");
        dockerCmd.add("--rm"); // è¿è¡Œå®Œç«‹å³åˆ é™¤å®¹å™¨ï¼Œä¿æŒæ¸…æ´
        dockerCmd.add("-v");
        // å…³é”®ï¼šå°†å®¿ä¸»æœºè·¯å¾„æ˜ å°„åˆ°å®¹å™¨å†…çš„ /src
        dockerCmd.add(hostSourcePath.toAbsolutePath() + ":/src"); 
        dockerCmd.add(sandboxImage);
        
        // è¿½åŠ å®é™…è¦æ‰§è¡Œçš„å‘½ä»¤
        dockerCmd.addAll(List.of(command));

        try {
            log.info("ğŸš€ Executing: {}", String.join(" ", dockerCmd));
            
            ProcessBuilder pb = new ProcessBuilder(dockerCmd);
            pb.redirectErrorStream(true); // åˆå¹¶ æ ‡å‡†è¾“å‡º å’Œ é”™è¯¯è¾“å‡º

            Process process = pb.start();

            // å¼‚æ­¥è¯»å–è¾“å‡ºï¼Œé˜²æ­¢å¡æ­»
            StreamGobbler gobbler = new StreamGobbler(process.getInputStream(), line -> {
                log.info("[Sandbox-STDOUT]: {}", line);
            });
            Executors.newSingleThreadExecutor().submit(gobbler);

            // ç­‰å¾…æ‰§è¡Œå®Œæˆ (ç”Ÿäº§ç¯å¢ƒå»ºè®®åŠ è¶…æ—¶æ§åˆ¶)
            int exitCode = process.waitFor();
            
            if (exitCode == 0) {
                log.info("âœ… Sandbox execution finished successfully.");
            } else {
                log.error("âŒ Sandbox execution failed with code: {}", exitCode);
            }

        } catch (Exception e) {
            log.error("Sandbox failure", e);
            throw new RuntimeException("Docker execution failed", e);
        }
    }
}
ç¬¬ä¸‰æ­¥ï¼šé…ç½®ä¸é•œåƒå‡†å¤‡ (Pre-check)
åœ¨ä½ çš„ Platform æœåŠ¡å™¨ï¼ˆæˆ–æœ¬æœºï¼‰ä¸Šï¼š

ç¡®ä¿å®‰è£…äº† Dockerã€‚

æ‹‰å–åŸºç¡€é•œåƒï¼š ä¸ºäº†éªŒè¯ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªåŸºç¡€ Linux é•œåƒã€‚

Bash

docker pull ubuntu:latest
é…ç½®æ–‡ä»¶ (healflow-platform/.../application.yml)ï¼š

YAML

healflow:
sandbox:
image: "ubuntu:latest"
ç¬¬å››æ­¥ï¼šé›†æˆåˆ° IncidentService (Platform)
ç°åœ¨æŠŠ Git å‡†å¤‡å¥½ä¹‹åï¼Œè¿æ¥ä¸Š Docker æ²™ç®±ã€‚

ä¿®æ”¹ healflow-platform/.../service/IncidentService.javaï¼š

Java

@Service
public class IncidentService {

    // ... logger
    private final GitWorkspaceManager gitManager;
    private final DockerSandboxManager sandboxManager; // <--- æ³¨å…¥æ–°ç»„ä»¶

    public IncidentService(GitWorkspaceManager gitManager, DockerSandboxManager sandboxManager) {
        this.gitManager = gitManager;
        this.sandboxManager = sandboxManager;
    }

    @Async
    public void processIncident(IncidentReport report) {
        log.info("âš™ï¸ Start processing incident for {}", report.appId());

        try {
            // 1. å‡†å¤‡æºç  (Phase 2)
            Path sourceCodePath = gitManager.prepareWorkspace(
                report.appId(),
                report.repoUrl(),
                report.commitId()
            );
            log.info("âœ… Source code ready at: {}", sourceCodePath);

            // 2. å¯åŠ¨æ²™ç®±éªŒè¯ (Phase 3)
            // æˆ‘ä»¬æ‰§è¡Œ "ls -al /src" æ¥è¯æ˜å®¹å™¨å†…èƒ½çœ‹åˆ°å®¿ä¸»æœºçš„ä»£ç 
            log.info("ğŸ•µï¸ Starting Sandbox Investigation...");
            sandboxManager.runInSandbox(
                report.appId(), 
                sourceCodePath, 
                "ls", "-al", "/src" // <--- åœ¨å®¹å™¨å†…æ‰§è¡Œçš„å‘½ä»¤
            );

        } catch (Exception e) {
            log.error("âŒ Processing failed", e);
        }
    }
}