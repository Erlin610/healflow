Maven 多模块架构设计 和 关键实施路径。

一、 物理架构与 Maven 模块设计
我们将项目命名为 healflow。

1. 目录结构 (Project Layout)
Plaintext

healflow-root/               # [pom.xml] 父工程，管理版本号(BOM)
├── healflow-common/         # [pom.xml] 公共模块
│   └── src/main/java/com/healflow/common/
│       ├── dto/             # IncidentReportDTO, PatchProposalDTO
│       └── enums/           # AgentStatus (ANALYZING, WAITING_AUTH, DONE)
│
├── healflow-starter/        # [pom.xml] 客户端 SDK (Spring Boot Starter)
│   └── src/main/java/com/healflow/starter/
│       ├── config/          # HealFlowAutoConfiguration
│       ├── listener/        # ExceptionListener (核心捕获逻辑)
│       └── util/            # GitPropertiesLoader (读取 git.properties)
│
├── healflow-engine/         # [pom.xml] 核心处理引擎 (Git + Docker 编排)
│   └── src/main/java/com/healflow/engine/
│       ├── git/             # JGitManager (Host侧 Git 操作)
│       └── sandbox/         # DockerSandboxManager (ProcessBuilder 交互逻辑)
│
└── healflow-platform/       # [pom.xml] 服务端 Web 应用
    └── src/main/java/com/healflow/platform/
        ├── controller/      # ReportController (接收 SDK 上报)
        ├── service/         # HealingService (调度 Engine)
        └── repository/      # JPA/MyBatis (存储事故记录)
2. 关键依赖管理 (Parent POM)
在根 pom.xml 中，你需要锁定核心技术的版本：

XML

<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.eclipse.jgit</groupId>
            <artifactId>org.eclipse.jgit</artifactId>
            <version>6.8.0.202311291450-r</version>
        </dependency>
        <dependency>
            <groupId>com.squareup.okhttp3</groupId>
            <artifactId>okhttp</artifactId>
            <version>4.12.0</version>
        </dependency>
        <dependency>
            <groupId>commons-io</groupId>
            <artifactId>commons-io</artifactId>
            <version>2.15.1</version>
        </dependency>
    </dependencies>
</dependencyManagement>
二、 实施步骤拆解 (Implementation Steps)
建议按以下 5 个阶段进行开发，每个阶段都是一个可验证的里程碑。

Phase 1: The Messenger (信使 - 打通上报链路)
目标：SDK 能捕获异常并发送给 Platform，Platform 能收到并打印。

构建 healflow-common: 定义 IncidentReport 类 (包含 appName, stackTrace, commitId)。

构建 healflow-platform: 写一个简单的 @PostMapping("/report") 接口。

构建 healflow-starter:

实现 SpringApplicationRunListener 或 AOP 切面来捕获全局异常。

使用 OkHttp 将异常 DTO 序列化发送给 Platform。

关键点: 实现 GitPropertiesLoader。SDK 需要读取 classpath:git.properties 文件（这依赖于用户项目使用了 git-commit-id-maven-plugin，这是业界标准）。

Phase 2: The Librarian (图书管理员 - 宿主机代码同步)
目标：Platform 根据 CommitID 在本地磁盘准备好源码。

构建 healflow-engine:

引入 JGit。

编写 WorkspaceService。

逻辑:

入参: gitUrl, commitId。

检查 /data/workspace/{appName} 是否存在。

不存在 -> Git.cloneRepository()。

存在 -> git.fetch() -> git.reset().setMode(ResetType.HARD).setRef(commitId)。

验证: 手动触发一个报错，看 Platform 的 /data/workspace 目录下是否真的出现了该版本的源码。

Phase 3: The Jailer (狱卒 - Docker 沙箱挂载)
目标：Java 能启动 Docker，且容器内能看到宿主机的代码。

编写 DockerSandbox 类:

不一定非要用 testcontainers (它偏向测试)，直接用 ProcessBuilder 调用 docker 命令行可能更直观且易调试。

启动命令:

Bash

docker run -d --name {taskId} \
  -v /host/workspace/{appName}:/container/src \
  -e ANTHROPIC_API_KEY=... \
  my-agent-image:latest tail -f /dev/null
(注: tail -f /dev/null 是为了让容器保持运行，等待我们 exec 进去)

验证: Java 代码执行后，在终端用 docker exec -it {taskId} ls /container/src 能看到源码。

Phase 4: The Puppet Master (傀儡师 - 交互式 Agent 操控)
目标：实现自动应答，让 Agent 跑起来。

核心难点攻关: 编写 InteractiveShellRunner。

使用 ProcessBuilder 执行 docker exec -i {taskId} claude analyze ...。

重点: 必须重定向 ErrorStream (pb.redirectErrorStream(true))。

重点: 开启一个独立线程读取 InputStream (Agent 的输出)。

重点: 在读取线程中做正则匹配 (Regex Match)。

如果匹配到 (y/n) -> 写入 outputStream.write("y\n")。

Mock 测试: 写一个 Python 脚本模拟 Claude，故意问一些问题，验证 Java 能否自动回答。

Phase 5: The Closer (终结者 - 生成补丁)
目标：提取修改结果。

Agent 修改完容器内的文件后（其实就是修改了宿主机文件）。

Java 调用 JGit 执行 git diff > fix.patch。

将 Patch 内容存入数据库。

发送通知。

三、 核心代码预演：Git Commit ID 获取
SDK 最关键的一步是准确获取版本。如果拿不到版本，Agent 就不知道该修复哪行代码。

在 healflow-starter 中，建议包含这个工具类：

Java

// healflow-starter/.../GitInfoCollector.java
public class GitInfoCollector {
    public String getCommitId() {
        try {
            Properties props = new Properties();
            // 约定：用户必须配置 git-commit-id-plugin 生成此文件
            Resource resource = new DefaultResourceLoader()
                .getResource("classpath:git.properties");
            
            if (resource.exists()) {
                props.load(resource.getInputStream());
                return props.getProperty("git.commit.id.full");
            }
        } catch (Exception e) {
            // log error
        }
        return "HEAD"; // 降级策略
    }
}