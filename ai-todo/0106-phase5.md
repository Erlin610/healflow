# Phase 5: The Architect & Orchestrator (AI æ ¸å¿ƒé›†æˆ)

## ğŸ¯ æ ¸å¿ƒè®¾è®¡æ€è·¯

### é•œåƒæ„å»º (Build Time)
- å°† AI å·¥å…· (claude-code) å’Œç¯å¢ƒä¾èµ–æ‰“åŒ…
- é…ç½®æƒé™ç­–ç•¥ï¼ˆä½¿ç”¨ `settings.json`ï¼Œè€Œé `autoApprove`ï¼‰
- ä¸åŒ…å«ä»»ä½•å¯†é’¥ä¿¡æ¯

### è¿è¡Œæ—¶æ³¨å…¥ (Run Time)
- **å¯†é’¥å®‰å…¨**: API Key å­˜å‚¨åœ¨å®¿ä¸»æœºçš„ `~/.claude/settings.json` ä¸­ï¼ŒJava åœ¨å¯åŠ¨å®¹å™¨æ—¶é€šè¿‡ç¯å¢ƒå˜é‡ (`-e`) æ³¨å…¥
- **æŒ‚è½½ä»£ç **: å®¿ä¸»æœºæºç æŒ‚è½½åˆ°å®¹å™¨ `/src`

### è°ƒåº¦æµç¨‹ (Orchestration)
é‡‡ç”¨**å¤šé˜¶æ®µå·¥ä½œæµ**ï¼Œæ¯ä¸ªé˜¶æ®µéœ€è¦ç”¨æˆ·ç¡®è®¤ï¼š

```
é˜¶æ®µ1: åˆ†æ bug (åªè¯»æƒé™)
  â†“
ç”¨æˆ·ç¡®è®¤åˆ†æç»“æœ
  â†“
é˜¶æ®µ2: ç”Ÿæˆä¿®å¤æ–¹æ¡ˆ (åªè¯»æƒé™)
  â†“
ç”¨æˆ·ç¡®è®¤ä¿®å¤æ–¹æ¡ˆ
  â†“
é˜¶æ®µ3: åº”ç”¨ä¿®å¤å¹¶æµ‹è¯• (å†™å…¥æƒé™)
```

## ğŸ› ï¸ æ­¥éª¤ä¸€ï¼šç›®å½•ç»“æ„å‡†å¤‡

åœ¨ `healflow-engine` æ¨¡å—ä¸‹åˆ›å»ºå¦‚ä¸‹æ–‡ä»¶ç»“æ„ï¼š

```
healflow-engine/src/main/resources/docker/
â”œâ”€â”€ Dockerfile                      # é•œåƒæ„å»ºè„šæœ¬
â””â”€â”€ config/
    â””â”€â”€ settings.json               # Claude é…ç½®æ–‡ä»¶ï¼ˆæƒé™ç­–ç•¥ï¼‰
```

**æ³¨æ„**: ä¸å†éœ€è¦ `claude-extensions/commands/` å’Œ `agents/` ç›®å½•ï¼Œå› ä¸ºæˆ‘ä»¬ä½¿ç”¨ `-p` æ¨¡å¼è€Œé slash commandsã€‚

### åˆ›å»º settings.json

æ–‡ä»¶è·¯å¾„: `healflow-engine/src/main/resources/docker/config/settings.json`

```json
{
  "permissions": {
    "allow": [
      "Read(**/*)",
      "Grep(**/*)",
      "Glob(**/*)",
      "Bash(git:*)",
      "Bash(mvn:*)",
      "Edit(**/*)",
      "Write(**/*)"
    ],
    "deny": [
      "Read(.env)",
      "Read(settings.json)",
      "Bash(rm:*)",
      "Bash(sudo:*)"
    ]
  }
}
```

## ğŸ³ æ­¥éª¤äºŒï¼šç¼–å†™ Dockerfile

æ–‡ä»¶è·¯å¾„: `healflow-engine/src/main/resources/docker/Dockerfile`

```dockerfile
# ä½¿ç”¨ Node.js 20 è½»é‡ç‰ˆä½œä¸ºåŸºç¡€
FROM node:20-bullseye-slim

# å®‰è£…åŸºç¡€å·¥å…·
# git: å¿…é¡»ï¼ŒAI éœ€è¦çœ‹ git å†å²
# ripgrep (rg): å¿…é¡»ï¼Œclaude-code ä¾èµ–çš„é«˜æ•ˆæœç´¢
# dumb-init: è¿›ç¨‹å®ˆæŠ¤ï¼Œé˜²æ­¢å®¹å™¨åƒµæ­»
RUN apt-get update && apt-get install -y \
    git \
    curl \
    ripgrep \
    dumb-init \
    && rm -rf /var/lib/apt/lists/*

# å…¨å±€å®‰è£… claude-code
RUN npm install -g @anthropic-ai/claude-code

# åˆ›å»ºé…ç½®ç›®å½•ç»“æ„ (Claude Code é»˜è®¤è¯»å– /root/.claude)
RUN mkdir -p /root/.claude

# æ³¨å…¥é…ç½®ï¼šé…ç½®æƒé™ç­–ç•¥
COPY config/settings.json /root/.claude/settings.json

# è®¾ç½®å·¥ä½œç›®å½• (å°†æŒ‚è½½å®¿ä¸»æœºæºç )
WORKDIR /src

# ç¯å¢ƒå˜é‡å£°æ˜ (è¿è¡Œæ—¶æ³¨å…¥)
ENV ANTHROPIC_API_KEY=""
ENV CI=true
ENV CLAUDE_NO_UPDATE_NOTIFIER=true

# å¯åŠ¨å…¥å£
ENTRYPOINT ["/usr/bin/dumb-init", "--"]
# é»˜è®¤ä¿æŒç©ºè½¬ï¼Œç­‰å¾… Java è°ƒç”¨ exec æˆ– run
CMD ["tail", "-f", "/dev/null"]
```

## â˜• æ­¥éª¤ä¸‰ï¼šåˆ›å»ºæ•°æ®ç±»

åœ¨ `healflow-common` æ¨¡å—åˆ›å»ºä»¥ä¸‹æ•°æ®ç±»ï¼š

### AnalysisResult.java
```java
package com.healflow.common.dto;

public record AnalysisResult(
    String sessionId,
    String structuredOutput,
    String fullText
) {}
```

### FixProposal.java
```java
package com.healflow.common.dto;

public record FixProposal(
    String sessionId,
    String structuredOutput,
    String fullText
) {}
```

### FixResult.java
```java
package com.healflow.common.dto;

public record FixResult(
    String result,
    String usage
) {}
```

## â˜• æ­¥éª¤å››ï¼šå®ç° IncidentService å¤šé˜¶æ®µæ–¹æ³•

åœ¨ `IncidentService` ä¸­æ·»åŠ ä»¥ä¸‹æ–¹æ³•ï¼š

### 1. è¾…åŠ©æ–¹æ³•ï¼šè¯»å– API Key

```java
private String getApiKeyFromHost() {
    try {
        File settingsFile = new File(System.getProperty("user.home"), ".claude/settings.json");
        if (settingsFile.exists()) {
            JsonNode root = objectMapper.readTree(settingsFile);
            return root.path("env").path("ANTHROPIC_API_KEY").asText();
        }
    } catch (Exception e) {
        log.error("Failed to read settings.json", e);
    }
    return System.getenv("ANTHROPIC_API_KEY");
}

private String truncate(String text, int maxLength) {
    if (text == null) return "";
    return text.length() > maxLength ? text.substring(0, maxLength) + "..." : text;
}
```

### 2. é˜¶æ®µ1ï¼šåˆ†æ bug

```java
public AnalysisResult analyzeIncident(IncidentReport report) {
    log.info("Phase 5 Stage 1: Analyzing incident for {}", report.appId());

    try {
        Path sourceCodePath = gitManager.prepareWorkspace(report.appId(), report.repoUrl(), report.branch());
        String apiKey = getApiKeyFromHost();
        if (apiKey == null || apiKey.isBlank()) {
            throw new RuntimeException("No API Key found");
        }

        String prompt = String.format(
            "Analyze this Java application error:\n" +
            "Error Type: %s\n" +
            "Error Message: %s\n" +
            "Stack Trace:\n%s\n\n" +
            "Provide detailed analysis but DO NOT generate fix yet.",
            report.errorType(),
            report.errorMessage(),
            truncate(report.stackTrace(), 1000)
        );

        String jsonSchema = """
            {
              "type": "object",
              "properties": {
                "bug_type": {"type": "string"},
                "severity": {"type": "string", "enum": ["critical", "high", "medium", "low"]},
                "root_cause": {"type": "string"},
                "affected_files": {"type": "array", "items": {"type": "string"}},
                "analysis": {"type": "string"},
                "confidence": {"type": "number", "minimum": 0, "maximum": 1}
              },
              "required": ["bug_type", "severity", "root_cause", "analysis", "confidence"]
            }
            """;

        List<String> command = List.of(
            "claude", "-p", prompt,
            "--allowedTools", "Read,Grep,Glob",
            "--output-format", "json",
            "--json-schema", jsonSchema,
            "--max-turns", "3"
        );

        String containerName = buildContainerName(report.appId());
        CommandResult result = dockerSandboxManager.executeInteractiveRunInSandbox(
            containerName,
            sourceCodePath,
            "/src",
            aiAgentImage,
            Map.of("ANTHROPIC_API_KEY", apiKey),
            command,
            Duration.ofMinutes(10),
            List.of()
        );

        JsonNode response = objectMapper.readTree(result.output());
        String sessionId = response.path("session_id").asText();
        String structuredOutput = response.path("structured_output").toString();
        String fullText = response.path("result").asText();

        log.info("Analysis complete. Session ID: {}", sessionId);
        return new AnalysisResult(sessionId, structuredOutput, fullText);

    } catch (Exception e) {
        log.error("Analysis failed", e);
        throw new RuntimeException("Analysis failed", e);
    }
}
```

### 3. é˜¶æ®µ2ï¼šç”Ÿæˆä¿®å¤æ–¹æ¡ˆ

```java
public FixProposal generateFix(String sessionId, Path sourceCodePath) {
    log.info("Phase 5 Stage 2: Generating fix for session {}", sessionId);

    try {
        String apiKey = getApiKeyFromHost();
        if (apiKey == null || apiKey.isBlank()) {
            throw new RuntimeException("No API Key found");
        }

        String prompt = "Based on the analysis, generate a detailed fix proposal. " +
                       "Show the code changes but DO NOT apply them yet.";

        String jsonSchema = """
            {
              "type": "object",
              "properties": {
                "fix_description": {"type": "string"},
                "files_to_modify": {"type": "array", "items": {"type": "string"}},
                "code_changes": {"type": "string"},
                "test_strategy": {"type": "string"},
                "risk_level": {"type": "string", "enum": ["low", "medium", "high"]}
              },
              "required": ["fix_description", "files_to_modify", "code_changes"]
            }
            """;

        List<String> command = List.of(
            "claude", "-p", prompt,
            "--resume", sessionId,  // ç»§ç»­ä¹‹å‰çš„ä¼šè¯
            "--allowedTools", "Read",
            "--output-format", "json",
            "--json-schema", jsonSchema,
            "--max-turns", "2"
        );

        String containerName = buildContainerName("fix-gen");
        CommandResult result = dockerSandboxManager.executeInteractiveRunInSandbox(
            containerName,
            sourceCodePath,
            "/src",
            aiAgentImage,
            Map.of("ANTHROPIC_API_KEY", apiKey),
            command,
            Duration.ofMinutes(5),
            List.of()
        );

        JsonNode response = objectMapper.readTree(result.output());
        String structuredOutput = response.path("structured_output").toString();
        String fullText = response.path("result").asText();

        log.info("Fix proposal generated");
        return new FixProposal(sessionId, structuredOutput, fullText);

    } catch (Exception e) {
        log.error("Fix generation failed", e);
        throw new RuntimeException("Fix generation failed", e);
    }
}
```

### 4. é˜¶æ®µ3ï¼šåº”ç”¨ä¿®å¤

```java
public FixResult applyFix(String sessionId, Path sourceCodePath) {
    log.info("Phase 5 Stage 3: Applying fix for session {}", sessionId);

    try {
        String apiKey = getApiKeyFromHost();
        if (apiKey == null || apiKey.isBlank()) {
            throw new RuntimeException("No API Key found");
        }

        String prompt = "Apply the fix we discussed. " +
                       "Make the code changes and run tests to verify.";

        List<String> command = List.of(
            "claude", "-p", prompt,
            "--resume", sessionId,  // ç»§ç»­ä¹‹å‰çš„ä¼šè¯
            "--allowedTools", "Read,Edit,Write,Bash(mvn test:*)",
            "--output-format", "json",
            "--max-turns", "5"
        );

        String containerName = buildContainerName("fix-apply");
        CommandResult result = dockerSandboxManager.executeInteractiveRunInSandbox(
            containerName,
            sourceCodePath,
            "/src",
            aiAgentImage,
            Map.of("ANTHROPIC_API_KEY", apiKey),
            command,
            Duration.ofMinutes(15),
            List.of()
        );

        JsonNode response = objectMapper.readTree(result.output());
        String resultText = response.path("result").asText();
        String usage = response.path("usage").toString();

        log.info("Fix applied successfully");
        return new FixResult(resultText, usage);

    } catch (Exception e) {
        log.error("Fix application failed", e);
        throw new RuntimeException("Fix application failed", e);
    }
}
```

## ğŸŒ æ­¥éª¤äº”ï¼šå®ç° REST API ç«¯ç‚¹

åœ¨ `IncidentController` ä¸­æ·»åŠ ä»¥ä¸‹ç«¯ç‚¹ï¼š

```java
// å­˜å‚¨ sessionId å’Œ workspace çš„æ˜ å°„
private final Map<String, String> sessionStore = new ConcurrentHashMap<>();
private final Map<String, Path> workspaceStore = new ConcurrentHashMap<>();

@PostMapping("/{id}/analyze")
public ResponseEntity<AnalysisResult> analyze(@PathVariable String id, @RequestBody IncidentReport report) {
    log.info("Starting analysis for incident: {}", id);
    try {
        AnalysisResult result = incidentService.analyzeIncident(report);
        sessionStore.put(id, result.sessionId());
        workspaceStore.put(id, Paths.get(System.getProperty("java.io.tmpdir"), "healflow-workspace", report.appId()));
        return ResponseEntity.ok(result);
    } catch (Exception e) {
        log.error("Analysis failed for incident: {}", id, e);
        return ResponseEntity.internalServerError().build();
    }
}

@PostMapping("/{id}/generate-fix")
public ResponseEntity<FixProposal> generateFix(@PathVariable String id) {
    log.info("Generating fix for incident: {}", id);
    try {
        String sessionId = sessionStore.get(id);
        Path workspace = workspaceStore.get(id);
        if (sessionId == null || workspace == null) {
            return ResponseEntity.badRequest().build();
        }
        FixProposal proposal = incidentService.generateFix(sessionId, workspace);
        return ResponseEntity.ok(proposal);
    } catch (Exception e) {
        log.error("Fix generation failed for incident: {}", id, e);
        return ResponseEntity.internalServerError().build();
    }
}

@PostMapping("/{id}/apply-fix")
public ResponseEntity<FixResult> applyFix(@PathVariable String id) {
    log.info("Applying fix for incident: {}", id);
    try {
        String sessionId = sessionStore.get(id);
        Path workspace = workspaceStore.get(id);
        if (sessionId == null || workspace == null) {
            return ResponseEntity.badRequest().build();
        }
        FixResult result = incidentService.applyFix(sessionId, workspace);
        sessionStore.remove(id);
        workspaceStore.remove(id);
        return ResponseEntity.ok(result);
    } catch (Exception e) {
        log.error("Fix application failed for incident: {}", id, e);
        return ResponseEntity.internalServerError().build();
    }
}
```

## ğŸš€ æ‰§è¡ŒéªŒè¯æ¸…å•

### 1. æ„å»ºé•œåƒ

```bash
cd healflow-engine/src/main/resources/docker
docker build -t healflow-agent:v1 .
```

### 2. éªŒè¯é•œåƒ

```bash
# æµ‹è¯• Claude Code æ˜¯å¦æ­£ç¡®å®‰è£…
docker run --rm -it -v $(pwd):/src -e ANTHROPIC_API_KEY=xxx healflow-agent:v1 claude --version
```

### 3. é›†æˆæµ‹è¯•

#### æ­¥éª¤1ï¼šè§¦å‘åˆ†æ
```bash
curl -X POST http://localhost:8080/api/v1/incidents/test-001/analyze \
  -H "Content-Type: application/json" \
  -d '{
    "appId": "demo-service-01",
    "repoUrl": "https://github.com/your/repo.git",
    "branch": "main",
    "errorType": "NullPointerException",
    "errorMessage": "Cannot invoke method on null object",
    "stackTrace": "..."
  }'
```

**é¢„æœŸè¾“å‡º**:
```json
{
  "sessionId": "session_abc123",
  "structuredOutput": "{\"bug_type\":\"NullPointerException\",\"severity\":\"high\",...}",
  "fullText": "Analysis: The error occurs because..."
}
```

#### æ­¥éª¤2ï¼šç”¨æˆ·ç¡®è®¤åï¼Œç”Ÿæˆä¿®å¤æ–¹æ¡ˆ
```bash
curl -X POST http://localhost:8080/api/v1/incidents/test-001/generate-fix
```

**é¢„æœŸè¾“å‡º**:
```json
{
  "sessionId": "session_abc123",
  "structuredOutput": "{\"fix_description\":\"Add null check\",\"files_to_modify\":[\"Foo.java\"],...}",
  "fullText": "Fix proposal: Add null check before method invocation..."
}
```

#### æ­¥éª¤3ï¼šç”¨æˆ·ç¡®è®¤åï¼Œåº”ç”¨ä¿®å¤
```bash
curl -X POST http://localhost:8080/api/v1/incidents/test-001/apply-fix
```

**é¢„æœŸè¾“å‡º**:
```json
{
  "result": "Fix applied successfully. Tests passed.",
  "usage": "{\"input_tokens\":1234,\"output_tokens\":567}"
}
```

## ğŸ“Š å·¥ä½œæµç¨‹å›¾

```
ç”¨æˆ·è§¦å‘å¼‚å¸¸ä¸ŠæŠ¥
    â†“
POST /api/v1/incidents/{id}/analyze
    â†“
è¿”å›åˆ†æç»“æœï¼ˆbugç±»å‹ã€ä¸¥é‡ç¨‹åº¦ã€æ ¹å› ã€ç½®ä¿¡åº¦ï¼‰
    â†“
[ç”¨æˆ·ç¡®è®¤] è°ƒç”¨ POST /api/v1/incidents/{id}/generate-fix
    â†“
è¿”å›ä¿®å¤æ–¹æ¡ˆï¼ˆè¦ä¿®æ”¹çš„æ–‡ä»¶ã€ä»£ç å˜æ›´ã€é£é™©ç­‰çº§ï¼‰
    â†“
[ç”¨æˆ·ç¡®è®¤] è°ƒç”¨ POST /api/v1/incidents/{id}/apply-fix
    â†“
è¿”å›ä¿®å¤ç»“æœå’Œæµ‹è¯•ç»“æœ
```

## âœ… å…³é”®ç‰¹æ€§

1. **å¤šé˜¶æ®µæ§åˆ¶**: ä½¿ç”¨ `--resume` ä¿æŒä¼šè¯ä¸Šä¸‹æ–‡ï¼Œæ¯ä¸ªé˜¶æ®µéœ€è¦ç”¨æˆ·ç¡®è®¤
2. **æ¸è¿›å¼æƒé™**: åˆ†æé˜¶æ®µåªè¯»ï¼Œä¿®å¤é˜¶æ®µæ‰æœ‰å†™æƒé™
3. **ç»“æ„åŒ–è¾“å‡º**: ä½¿ç”¨ `--json-schema` è·å–å¯è§£æçš„ JSON
4. **ç”¨æˆ·ç¡®è®¤**: æ¯ä¸ªé˜¶æ®µéƒ½éœ€è¦ç”¨æˆ·ä¸»åŠ¨è°ƒç”¨ API ç¡®è®¤
5. **ä¼šè¯ç®¡ç†**: Controller ä¸­ç»´æŠ¤ sessionId å’Œ workspace æ˜ å°„

## âš ï¸ é‡è¦ä¿®æ­£è¯´æ˜

ç›¸æ¯”åŸæ–¹æ¡ˆï¼Œæœ¬æ–¹æ¡ˆåšäº†ä»¥ä¸‹å…³é”®ä¿®æ­£ï¼š

1. **é…ç½®æ–‡ä»¶**: ä½¿ç”¨ `settings.json` è€Œé `config.json`ï¼Œä½¿ç”¨ `permissions.allow` è€Œé `autoApprove`
2. **æ‰§è¡Œæ¨¡å¼**: ä½¿ç”¨ `-p` æ¨¡å¼ï¼ˆéäº¤äº’å¼ï¼‰è€Œéäº¤äº’å¼ REPL
3. **å‘½ä»¤æ–¹å¼**: ç›´æ¥ä¼ é€’æç¤ºè¯ï¼Œè€Œéä½¿ç”¨ slash commands
4. **å¤šé˜¶æ®µå·¥ä½œæµ**: ä½¿ç”¨ `--resume` å®ç°å¤šé˜¶æ®µï¼Œæ¯é˜¶æ®µéœ€ç”¨æˆ·ç¡®è®¤
5. **ç»“æ„åŒ–è¾“å‡º**: ä½¿ç”¨ `--json-schema` è·å–å¯è§£æçš„å†³ç­–æ•°æ®

è¿™äº›ä¿®æ­£ç¡®ä¿äº†æ–¹æ¡ˆçš„å¯è¡Œæ€§å’Œå®‰å…¨æ€§ã€‚
