# 产品需求文档：HealFlow 智能治理引擎 (Phase 6)

## 项目内容

| 项目 | 内容 |
|------|------|
| 产品名称 | HealFlow (自愈流) |
| 模块 | Phase 6 - The Governor (治理与生命周期) |
| 版本 | v2.0 |
| 核心目标 | 降噪（去重）、闭环（生命周期管理）、可控（配置中心） |
| 目标用户 | 研发负责人、DevOps 工程师、高级开发人员 |

---

## 1. 产品愿景与核心价值

HealFlow 不应是一个只会报错的喇叭，而应是一位**"有记忆、懂分寸的数字员工"**。

- **有记忆**：它能识别"这是老毛病"还是"新问题"。
- **懂分寸**：它不会因为同一个死循环报错而在一分钟内轰炸你的手机 100 次。
- **可交付**：它最终交付的不是日志，而是修复方案。

---

## 2. 核心功能模块设计

### 模块一：智能噪音过滤器 (Intelligent Noise Filter)

这是本阶段最重要的"防洪堤"。我们需要将海量的 Log Events 聚类为少量的 Unique Issues。

#### 2.1 错误指纹 (The Error Fingerprint)

我们不比较整段日志，而是提取错误的**"基因片段"**。

**设计逻辑：**
- **强特征**：Exception Type (如 NPE) + Root StackTrace (业务代码的前 3 帧)。
- **弱特征**：忽略 Error Message 中的动态参数（如 "User ID 1001 not found" 中的 1001）。
- **指纹生成**：`Hash(ErrorType + CoreStack)`。

#### 2.2 聚合策略

**首次命中：**
- 系统无此指纹记录 → 创建新 Issue → 触发 AI 分析 → 发送通知。

**重复命中：**
- 系统已有此指纹 → 拦截。
- 仅增加 `occurrence_count`（发生次数）。
- 更新 `last_seen_time`。
- **静默处理**：不触发 AI，不发送通知（除非达到阈值，如"累计发生 1000 次"）。

---

### 模块二：全生命周期状态机 (Lifecycle State Machine)

我们要像管理 Jira 单据一样管理每一个 Bug。

#### 2.1 状态流转定义

**🔵 OPEN (新发现)**
- **含义**：全新的指纹，从未出现过。
- **动作**：立即启动 AI 介入分析。

**🟡 ANALYZING (分析中)**
- **含义**：Docker 容器正在运行，AI 正在思考。
- **UI 表现**：显示加载动画/进度条。

**🟠 PENDING_REVIEW (待确认)**
- **含义**：AI 已产出分析报告或修复方案，等待人类决策。
- **动作**：发送 Webhook 通知，附带"查看详情"按钮。

**🟢 FIXED (已修复)**
- **含义**：用户确认修复，或 AI 自动修复成功。
- **逻辑**：该指纹进入"休眠监控"名单。

**🔴 REGRESSION (回归/复发)** 🔥 **核心亮点**
- **含义**：状态为 FIXED 的指纹再次被探针捕获。
- **判定**：说明修复失败或代码回滚。
- **动作**：
  - 最高优先级告警。
  - AI 重新介入，Prompt 变更为"此问题曾被修复但复发了，请检查回归原因"。

---

### 模块三：中央控制台 (The Command Center)

UI 设计应遵循"极简运维"原则，分为概览、应用配置、问题详情三层。

#### 3.1 应用接入与配置 (App Onboarding)

用户接入一个新项目时，需要配置一张"身份证"。

**基础信息：**
- 应用名称 (AppID)。
- 源码仓库：Git URL + Branch (默认 main/master)。

**鉴权金库 (Vault)：**
- Git Access Token (加密存储，仅允许覆盖，不可查看明文)。
- AI API Key (支持继承全局配置或单独覆盖)。

**自动化策略 (Automation Policy)：**
- **Auto-Analyze**: 开/关 (建议默认开)。
- **Auto-Fix Proposal**: 开/关 (生成 Patch 但不提交)。
- **Auto-Commit**: 开/关 (高风险，需二次确认开启)。

**通知渠道：**
- Webhook 地址 (钉钉/飞书/Slack)，支持配置"仅通知新问题"或"通知所有回归"。

#### 3.2 问题详情页 (The War Room)

这是用户处理 Bug 的核心页面。

**头部：**
- Issue 标题 (如 NPE in UserService)、当前状态 (Badge)、累计发生次数、指纹 ID。

**左侧 (现场)：**
- 最近一次报错的 StackTrace。
- 关联的 Git Commit ID。
- 发生时间轴 (Sparkline 图表显示频率趋势)。

**右侧 (AI 诊疗)：**
- **分析报告**：Markdown 渲染的 AI 分析结果。
- **修复方案**：代码 Diff 对比视图 (Old vs New)。

**操作区：**
- Generate Fix (如果尚未生成)。
- Apply Fix (提交代码)。
- Mark as Fixed (手动标记已解决，关闭关联的所有报警)。
- Ignore (标记为误报/无需修复)。

---

## 3. 业务交互流程 (User Journey)

### 场景 A：第一次遇到 Bug

1. **系统**：探针捕获异常 → 指纹计算(New) → 生成 Issue (OPEN) → 呼叫 AI。
2. **用户**：收到飞书卡片"发现新问题：UserService 空指针"。
3. **用户**：点击卡片进入详情页，看到 AI 已经写好的分析报告和建议代码。
4. **用户**：点击 "Apply Fix"。
5. **系统**：Docker 启动 → 应用补丁 → 提交 Git → 状态变更为 FIXED。

### 场景 B：Bug 疯狂刷屏

1. **系统**：探针持续捕获异常 → 指纹计算(Exist) → 发现是 OPEN 状态 → 仅计数 +1。
2. **用户**：不会收到 100 条通知，只会收到第 1 条。
3. **UI**：详情页上的"发生次数"实时跳动 (1 → 50 → 100)。

### 场景 C：Bug 诈尸 (回归)

1. **系统**：探针捕获异常 → 指纹计算(Exist) → 发现状态是 FIXED。
2. **系统**：判定为 REGRESSION → 状态变更 → 呼叫 AI (带上回归上下文)。
3. **用户**：收到红色高优告警："紧急！已修复的 UserService 空指针再次出现！"。

---

## 4. 关键设计决策 (Key Decisions)

### 去重粒度

- **选择**：我们选择"堆栈+类型"作为唯一标识。
- **决策依据**：这是唯一能客观代表代码逻辑错误的特征。
- **已知问题**：行号变化导致指纹变化的问题，留给后续版本通过"模糊匹配"解决，Phase 6 先做精确匹配。

### Token 安全

- 所有敏感字段 (Git Token, API Key) 在前端输入后，后端立即加密入库。
- 返回前端时仅显示 `******` 或掩码，绝不回显明文。

### Docker 资源保护

- 引入**"分析冷却期"**。
- 如果一个 Issue 正在 ANALYZING 状态，后续相同的报错直接丢弃，不启动新的分析，防止把服务器跑挂。

---

## 5. 交付物清单 (Deliverables)

- [ ] **API 契约**：定义好的 App 管理和 Issue 操作 RESTful 接口。
- [ ] **数据模型**：设计好的 Issue 和 Application 实体关系图 (ERD)。
- [ ] **去重算法**：经过单元测试验证的 Fingerprint 生成逻辑。
